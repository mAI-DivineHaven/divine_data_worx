"""
Search router providing FTS, vector, and hybrid search endpoints.

Implements three search strategies for biblical text retrieval:
1. Full-text search (FTS): Lexical matching using PostgreSQL text search
2. Vector search: Semantic similarity using pgvector embeddings
3. Hybrid search: Reciprocal Rank Fusion (RRF) combining FTS + vector

All endpoints support translation filtering and pagination.
Response format includes relevance scores for ranking.

Example Usage:
    ```bash
    # Full-text search
    curl "http://localhost:8000/v1/search/fts?q=love&translation=NIV&limit=10"

    # Vector search (POST with embedding)
    curl -X POST "http://localhost:8000/v1/search/vector" \\
      -H "Content-Type: application/json" \\
      -d '{"embedding": [...], "dim": 768, "model": "embeddinggemma", "top_k": 10}'

    # Hybrid search (POST with text + embedding)
    curl -X POST "http://localhost:8000/v1/search/hybrid" \\
      -H "Content-Type: application/json" \\
      -d '{"q": "love", "embedding": [...], "dim": 768, "model": "embeddinggemma"}'
    ```
"""

import asyncpg
from fastapi import APIRouter, Depends, HTTPException

from ..db.postgres_async import get_pg
from ..models import FTSQuery, HybridQuery, SearchResponse, VectorQuery
from ..services.search_api import SearchApiService

router = APIRouter(prefix="/search", tags=["search"])


def get_search_service(conn: asyncpg.Connection = Depends(get_pg)) -> SearchApiService:
    """Dependency provider for :class:`SearchApiService` instances."""

    return SearchApiService(conn)


@router.post("/fts", response_model=SearchResponse)
async def search_fts(
    body: FTSQuery,
    service: SearchApiService = Depends(get_search_service),
) -> SearchResponse:
    """Full-text search using PostgreSQL FTS with configurable dictionary.

    Performs lexical matching against verse text using PostgreSQL's text search
    capabilities. Supports phrase queries and diacritic handling via the
    configured FTS dictionary (``simple``/``simple_unaccent``).

    Args:
        body: Validated :class:`~backend.app.models.FTSQuery` request payload.
        service: SearchApiService dependency (injected by FastAPI).

    Returns:
        SearchResponse with total count and ranked results.

    Response Format:
        ``{"total": 150, "items": [{"verse_id": "NIV_43_3_16_", "text": "...", "score": 0.82}]}``

    Performance:
        Uses ``ts_rank_cd`` for ranking with a GIN index on ``to_tsvector``.
        Typical query time: 5-50ms depending on result set size.
    """
    try:
        return await service.full_text_search(body)
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc


@router.post("/vector", response_model=SearchResponse)
async def search_vector(
    body: VectorQuery,
    service: SearchApiService = Depends(get_search_service),
) -> SearchResponse:
    """Semantic vector search using pgvector embeddings.

    Performs approximate nearest neighbour (ANN) search using cosine similarity
    on verse embeddings. Requires embeddings generated by the same model and
    dimension as specified in the query.

    Args:
        body: Validated :class:`~backend.app.models.VectorQuery` request.
        service: SearchApiService dependency (injected by FastAPI).

    Returns:
        SearchResponse with semantic similarity scores (0-1, higher is better).

    Request Body Example:
        ``{"embedding": [0.1, -0.2, ...], "model": "embeddinggemma", "dim": 768, "top_k": 10}``

    Raises:
        HTTPException: 400 if embedding length does not match ``dim``.

    Performance:
        Uses DiskANN index for sub-10ms query times.
        Cosine similarity computed as ``1 - (embedding <=> query_vector)``.
    """
    try:
        return await service.vector_search(body)
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc


@router.post("/hybrid", response_model=SearchResponse)
async def search_hybrid(
    body: HybridQuery,
    service: SearchApiService = Depends(get_search_service),
) -> SearchResponse:
    """Hybrid search using Reciprocal Rank Fusion (RRF) to combine FTS + vector.

    Fuses results from full-text search and semantic vector search using the
    RRF algorithm for best retrieval performance. Combines lexical and semantic
    understanding for superior results.

    RRF Formula: ``score(d) = Î£ 1 / (k + rank_i(d))`` for all result sets ``i``

    Args:
        body: Validated :class:`~backend.app.models.HybridQuery` request.
        service: SearchApiService dependency (injected by FastAPI).

    Returns:
        SearchResponse with RRF-fused results ordered by combined score.

    Request Body Example:
        ``{"q": "love", "embedding": [0.1, ...], "fts_k": 100, "vector_k": 100, "k_rrf": 60}``

    Raises:
        HTTPException: 400 if neither ``q`` nor ``embedding`` provided.
        HTTPException: 400 if embedding length does not match ``dim``.

    Performance:
        Typical query time: 10-50ms (FTS + vector in parallel, RRF fusion).
        Combines benefits of exact keyword matching and semantic understanding.

    Algorithm Reference:
        Cormack et al., "Reciprocal Rank Fusion outperforms Condorcet", SIGIR 2009
    """
    try:
        return await service.hybrid_search(body)
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc
